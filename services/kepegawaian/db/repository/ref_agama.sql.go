// Code generated by sqlc. DO NOT EDIT.
// source: ref_agama.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countRefAgama = `-- name: CountRefAgama :one
SELECT COUNT(1)
FROM ref_agama
WHERE deleted_at IS NULL
`

func (q *Queries) CountRefAgama(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countRefAgama)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRefAgama = `-- name: CreateRefAgama :one
INSERT INTO ref_agama (nama)
VALUES ($1)
RETURNING id, nama, created_at, updated_at
`

type CreateRefAgamaRow struct {
	ID        int32              `db:"id"`
	Nama      pgtype.Text        `db:"nama"`
	CreatedAt pgtype.Timestamptz `db:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at"`
}

func (q *Queries) CreateRefAgama(ctx context.Context, nama pgtype.Text) (CreateRefAgamaRow, error) {
	row := q.db.QueryRow(ctx, createRefAgama, nama)
	var i CreateRefAgamaRow
	err := row.Scan(
		&i.ID,
		&i.Nama,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRefAgama = `-- name: DeleteRefAgama :execrows
UPDATE ref_agama
SET deleted_at = now()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) DeleteRefAgama(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.Exec(ctx, deleteRefAgama, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getRefAgama = `-- name: GetRefAgama :one
SELECT id, nama, created_at, updated_at
FROM ref_agama
WHERE id = $1 AND deleted_at IS NULL
`

type GetRefAgamaRow struct {
	ID        int32              `db:"id"`
	Nama      pgtype.Text        `db:"nama"`
	CreatedAt pgtype.Timestamptz `db:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at"`
}

func (q *Queries) GetRefAgama(ctx context.Context, id int32) (GetRefAgamaRow, error) {
	row := q.db.QueryRow(ctx, getRefAgama, id)
	var i GetRefAgamaRow
	err := row.Scan(
		&i.ID,
		&i.Nama,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listRefAgama = `-- name: ListRefAgama :many
SELECT id, nama, created_at, updated_at
FROM ref_agama
WHERE deleted_at IS NULL
ORDER BY id
LIMIT $1 OFFSET $2
`

type ListRefAgamaParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

type ListRefAgamaRow struct {
	ID        int32              `db:"id"`
	Nama      pgtype.Text        `db:"nama"`
	CreatedAt pgtype.Timestamptz `db:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at"`
}

func (q *Queries) ListRefAgama(ctx context.Context, arg ListRefAgamaParams) ([]ListRefAgamaRow, error) {
	rows, err := q.db.Query(ctx, listRefAgama, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRefAgamaRow
	for rows.Next() {
		var i ListRefAgamaRow
		if err := rows.Scan(
			&i.ID,
			&i.Nama,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRefAgama = `-- name: UpdateRefAgama :one
UPDATE ref_agama
SET nama = $2, updated_at = now()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, nama, created_at, updated_at
`

type UpdateRefAgamaParams struct {
	ID   int32       `db:"id"`
	Nama pgtype.Text `db:"nama"`
}

type UpdateRefAgamaRow struct {
	ID        int32              `db:"id"`
	Nama      pgtype.Text        `db:"nama"`
	CreatedAt pgtype.Timestamptz `db:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at"`
}

func (q *Queries) UpdateRefAgama(ctx context.Context, arg UpdateRefAgamaParams) (UpdateRefAgamaRow, error) {
	row := q.db.QueryRow(ctx, updateRefAgama, arg.ID, arg.Nama)
	var i UpdateRefAgamaRow
	err := row.Scan(
		&i.ID,
		&i.Nama,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
