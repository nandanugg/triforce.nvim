// Code generated by sqlc. DO NOT EDIT.
// source: ref_template.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countTemplates = `-- name: CountTemplates :one
SELECT COUNT(1)
FROM ref_template
WHERE deleted_at IS NULL
`

func (q *Queries) CountTemplates(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countTemplates)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTemplate = `-- name: CreateTemplate :one
INSERT INTO ref_template (nama, filename, file_base64)
VALUES ($1::text, $2::text, $3::text)
RETURNING id, nama, filename, created_at, updated_at
`

type CreateTemplateParams struct {
	Name       string `db:"name"`
	Filename   string `db:"filename"`
	FileBase64 string `db:"file_base64"`
}

type CreateTemplateRow struct {
	ID        int32              `db:"id"`
	Nama      string             `db:"nama"`
	Filename  string             `db:"filename"`
	CreatedAt pgtype.Timestamptz `db:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at"`
}

func (q *Queries) CreateTemplate(ctx context.Context, arg CreateTemplateParams) (CreateTemplateRow, error) {
	row := q.db.QueryRow(ctx, createTemplate, arg.Name, arg.Filename, arg.FileBase64)
	var i CreateTemplateRow
	err := row.Scan(
		&i.ID,
		&i.Nama,
		&i.Filename,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteTemplate = `-- name: DeleteTemplate :execrows
UPDATE ref_template
SET deleted_at = NOW()
WHERE id = $1::integer AND deleted_at IS NULL
`

func (q *Queries) DeleteTemplate(ctx context.Context, id int32) (int64, error) {
	result, err := q.db.Exec(ctx, deleteTemplate, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getTemplate = `-- name: GetTemplate :one
SELECT id, nama, filename, created_at, updated_at
FROM ref_template
WHERE id = $1::integer AND deleted_at IS NULL
`

type GetTemplateRow struct {
	ID        int32              `db:"id"`
	Nama      string             `db:"nama"`
	Filename  string             `db:"filename"`
	CreatedAt pgtype.Timestamptz `db:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at"`
}

func (q *Queries) GetTemplate(ctx context.Context, id int32) (GetTemplateRow, error) {
	row := q.db.QueryRow(ctx, getTemplate, id)
	var i GetTemplateRow
	err := row.Scan(
		&i.ID,
		&i.Nama,
		&i.Filename,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTemplateBerkas = `-- name: GetTemplateBerkas :one
SELECT file_base64
FROM ref_template
WHERE id = $1::integer AND deleted_at IS NULL
`

func (q *Queries) GetTemplateBerkas(ctx context.Context, id int32) (pgtype.Text, error) {
	row := q.db.QueryRow(ctx, getTemplateBerkas, id)
	var file_base64 pgtype.Text
	err := row.Scan(&file_base64)
	return file_base64, err
}

const listTemplates = `-- name: ListTemplates :many
SELECT id, nama, filename, created_at, updated_at
FROM ref_template
WHERE deleted_at IS NULL
LIMIT $1 OFFSET $2
`

type ListTemplatesParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

type ListTemplatesRow struct {
	ID        int32              `db:"id"`
	Nama      string             `db:"nama"`
	Filename  string             `db:"filename"`
	CreatedAt pgtype.Timestamptz `db:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at"`
}

func (q *Queries) ListTemplates(ctx context.Context, arg ListTemplatesParams) ([]ListTemplatesRow, error) {
	rows, err := q.db.Query(ctx, listTemplates, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTemplatesRow
	for rows.Next() {
		var i ListTemplatesRow
		if err := rows.Scan(
			&i.ID,
			&i.Nama,
			&i.Filename,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTemplate = `-- name: UpdateTemplate :one
UPDATE ref_template
SET
	nama = $1::text,
	filename = $2::text,
	file_base64 = $3::text,
	updated_at = NOW()
WHERE id = $4::integer AND deleted_at IS NULL
RETURNING id, nama, filename, created_at, updated_at
`

type UpdateTemplateParams struct {
	Name       string `db:"name"`
	Filename   string `db:"filename"`
	FileBase64 string `db:"file_base64"`
	ID         int32  `db:"id"`
}

type UpdateTemplateRow struct {
	ID        int32              `db:"id"`
	Nama      string             `db:"nama"`
	Filename  string             `db:"filename"`
	CreatedAt pgtype.Timestamptz `db:"created_at"`
	UpdatedAt pgtype.Timestamptz `db:"updated_at"`
}

func (q *Queries) UpdateTemplate(ctx context.Context, arg UpdateTemplateParams) (UpdateTemplateRow, error) {
	row := q.db.QueryRow(ctx, updateTemplate,
		arg.Name,
		arg.Filename,
		arg.FileBase64,
		arg.ID,
	)
	var i UpdateTemplateRow
	err := row.Scan(
		&i.ID,
		&i.Nama,
		&i.Filename,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
