// Code generated by sqlc. DO NOT EDIT.
// source: resource_permission.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countActiveResourcePermissionsByIDs = `-- name: CountActiveResourcePermissionsByIDs :one
select count(1)
from resource_permission
where id = any($1::int4[]) and deleted_at is null
  and kode is not null -- kode is not null is alias for resource.deleted_at is null and permission.deleted_at is null
`

func (q *Queries) CountActiveResourcePermissionsByIDs(ctx context.Context, ids []int32) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveResourcePermissionsByIDs, ids)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countResources = `-- name: CountResources :one
select count(1)
from resource
where deleted_at is null
`

func (q *Queries) CountResources(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countResources)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listResourcePermissionsByNip = `-- name: ListResourcePermissionsByNip :many
select distinct rp.kode
from role_resource_permission rrp
join resource_permission rp on rp.id = rrp.resource_permission_id and rp.deleted_at is null
where rrp.role_id in (
  select ur.role_id
  from user_role ur
  join role r on r.id = ur.role_id and r.deleted_at is null
  where ur.nip = $1 and ur.deleted_at is null

  union all

  select r.id
  from role r
  where r.is_default and r.deleted_at is null
) and rrp.deleted_at is null
  and rp.kode is not null -- rp.kode is not null is alias for resource.deleted_at is null and permission.deleted_at is null
order by rp.kode
`

func (q *Queries) ListResourcePermissionsByNip(ctx context.Context, nip string) ([]pgtype.Text, error) {
	rows, err := q.db.Query(ctx, listResourcePermissionsByNip, nip)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.Text
	for rows.Next() {
		var kode pgtype.Text
		if err := rows.Scan(&kode); err != nil {
			return nil, err
		}
		items = append(items, kode)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourcePermissionsByResourceIDs = `-- name: ListResourcePermissionsByResourceIDs :many
select
  rp.resource_id,
  rp.id,
  rp.kode,
  p.nama as nama_permission
from resource_permission rp
join permission p on p.id = rp.permission_id and p.deleted_at is null
where rp.resource_id = any($1::int2[]) and rp.deleted_at is null
order by rp.kode
`

type ListResourcePermissionsByResourceIDsRow struct {
	ResourceID     int16       `db:"resource_id"`
	ID             int32       `db:"id"`
	Kode           pgtype.Text `db:"kode"`
	NamaPermission string      `db:"nama_permission"`
}

func (q *Queries) ListResourcePermissionsByResourceIDs(ctx context.Context, resourceIds []int16) ([]ListResourcePermissionsByResourceIDsRow, error) {
	rows, err := q.db.Query(ctx, listResourcePermissionsByResourceIDs, resourceIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListResourcePermissionsByResourceIDsRow
	for rows.Next() {
		var i ListResourcePermissionsByResourceIDsRow
		if err := rows.Scan(
			&i.ResourceID,
			&i.ID,
			&i.Kode,
			&i.NamaPermission,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResourcePermissionsByRoleID = `-- name: ListResourcePermissionsByRoleID :many
select
  rp.id,
  rp.kode,
  r.nama as nama_resource,
  p.nama as nama_permission
from role_resource_permission rrp
join resource_permission rp on rp.id = rrp.resource_permission_id and rp.deleted_at is null
join resource r on r.id = rp.resource_id and r.deleted_at is null
join permission p on p.id = rp.permission_id and p.deleted_at is null
where rrp.role_id = $1 and rrp.deleted_at is null
order by rp.kode
`

type ListResourcePermissionsByRoleIDRow struct {
	ID             int32       `db:"id"`
	Kode           pgtype.Text `db:"kode"`
	NamaResource   string      `db:"nama_resource"`
	NamaPermission string      `db:"nama_permission"`
}

func (q *Queries) ListResourcePermissionsByRoleID(ctx context.Context, roleID int16) ([]ListResourcePermissionsByRoleIDRow, error) {
	rows, err := q.db.Query(ctx, listResourcePermissionsByRoleID, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListResourcePermissionsByRoleIDRow
	for rows.Next() {
		var i ListResourcePermissionsByRoleIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Kode,
			&i.NamaResource,
			&i.NamaPermission,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listResources = `-- name: ListResources :many
select
  id,
  nama
from resource
where deleted_at is null
order by kode
limit $1 offset $2
`

type ListResourcesParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

type ListResourcesRow struct {
	ID   int16  `db:"id"`
	Nama string `db:"nama"`
}

func (q *Queries) ListResources(ctx context.Context, arg ListResourcesParams) ([]ListResourcesRow, error) {
	rows, err := q.db.Query(ctx, listResources, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListResourcesRow
	for rows.Next() {
		var i ListResourcesRow
		if err := rows.Scan(&i.ID, &i.Nama); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
