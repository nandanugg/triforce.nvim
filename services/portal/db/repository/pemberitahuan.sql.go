// Code generated by sqlc. DO NOT EDIT.
// source: pemberitahuan.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPemberitahuan = `-- name: CountPemberitahuan :one
SELECT COUNT(1) AS total
FROM pemberitahuan
WHERE deleted_at IS NULL
`

func (q *Queries) CountPemberitahuan(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countPemberitahuan)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createPemberitahuan = `-- name: CreatePemberitahuan :one
INSERT INTO pemberitahuan (
    judul_berita,
    deskripsi_berita,
    pinned,
    diterbitkan_pada,
    ditarik_pada,
    updated_by,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, now()
)
RETURNING
    id,
    judul_berita,
    deskripsi_berita,
    pinned,
    diterbitkan_pada,
    ditarik_pada,
    updated_by,
    updated_at,
    deleted_at,
    CASE
        WHEN NOW() < diterbitkan_pada THEN 'WAITING'
        WHEN NOW() >= diterbitkan_pada AND NOW() < ditarik_pada THEN 'ACTIVE'
        WHEN NOW() >= ditarik_pada THEN 'OVER'
        ELSE 'UNKNOWN'
    END AS status
`

type CreatePemberitahuanParams struct {
	JudulBerita     string             `db:"judul_berita"`
	DeskripsiBerita string             `db:"deskripsi_berita"`
	Pinned          bool               `db:"pinned"`
	DiterbitkanPada pgtype.Timestamptz `db:"diterbitkan_pada"`
	DitarikPada     pgtype.Timestamptz `db:"ditarik_pada"`
	UpdatedBy       string             `db:"updated_by"`
}

type CreatePemberitahuanRow struct {
	ID              int64              `db:"id"`
	JudulBerita     string             `db:"judul_berita"`
	DeskripsiBerita string             `db:"deskripsi_berita"`
	Pinned          bool               `db:"pinned"`
	DiterbitkanPada pgtype.Timestamptz `db:"diterbitkan_pada"`
	DitarikPada     pgtype.Timestamptz `db:"ditarik_pada"`
	UpdatedBy       string             `db:"updated_by"`
	UpdatedAt       pgtype.Date        `db:"updated_at"`
	DeletedAt       pgtype.Timestamptz `db:"deleted_at"`
	Status          string             `db:"status"`
}

func (q *Queries) CreatePemberitahuan(ctx context.Context, arg CreatePemberitahuanParams) (CreatePemberitahuanRow, error) {
	row := q.db.QueryRow(ctx, createPemberitahuan,
		arg.JudulBerita,
		arg.DeskripsiBerita,
		arg.Pinned,
		arg.DiterbitkanPada,
		arg.DitarikPada,
		arg.UpdatedBy,
	)
	var i CreatePemberitahuanRow
	err := row.Scan(
		&i.ID,
		&i.JudulBerita,
		&i.DeskripsiBerita,
		&i.Pinned,
		&i.DiterbitkanPada,
		&i.DitarikPada,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Status,
	)
	return i, err
}

const deletePemberitahuan = `-- name: DeletePemberitahuan :execrows
UPDATE pemberitahuan
SET deleted_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
`

func (q *Queries) DeletePemberitahuan(ctx context.Context, id int64) (int64, error) {
	result, err := q.db.Exec(ctx, deletePemberitahuan, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const listPemberitahuan = `-- name: ListPemberitahuan :many
SELECT
    id,
    judul_berita,
    deskripsi_berita,
    pinned,
    diterbitkan_pada,
    ditarik_pada,
    updated_by,
    updated_at,
    deleted_at,
    CASE
        WHEN NOW() < diterbitkan_pada THEN 'WAITING'
        WHEN NOW() >= diterbitkan_pada AND NOW() < ditarik_pada THEN 'ACTIVE'
        WHEN NOW() >= ditarik_pada THEN 'OVER'
        ELSE 'UNKNOWN'
    END AS status
FROM pemberitahuan
WHERE deleted_at IS NULL
ORDER BY
    pinned DESC,
    diterbitkan_pada DESC
LIMIT $1 OFFSET $2
`

type ListPemberitahuanParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

type ListPemberitahuanRow struct {
	ID              int64              `db:"id"`
	JudulBerita     string             `db:"judul_berita"`
	DeskripsiBerita string             `db:"deskripsi_berita"`
	Pinned          bool               `db:"pinned"`
	DiterbitkanPada pgtype.Timestamptz `db:"diterbitkan_pada"`
	DitarikPada     pgtype.Timestamptz `db:"ditarik_pada"`
	UpdatedBy       string             `db:"updated_by"`
	UpdatedAt       pgtype.Date        `db:"updated_at"`
	DeletedAt       pgtype.Timestamptz `db:"deleted_at"`
	Status          string             `db:"status"`
}

func (q *Queries) ListPemberitahuan(ctx context.Context, arg ListPemberitahuanParams) ([]ListPemberitahuanRow, error) {
	rows, err := q.db.Query(ctx, listPemberitahuan, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPemberitahuanRow
	for rows.Next() {
		var i ListPemberitahuanRow
		if err := rows.Scan(
			&i.ID,
			&i.JudulBerita,
			&i.DeskripsiBerita,
			&i.Pinned,
			&i.DiterbitkanPada,
			&i.DitarikPada,
			&i.UpdatedBy,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePemberitahuan = `-- name: UpdatePemberitahuan :one
UPDATE pemberitahuan
SET
    judul_berita = $2,
    deskripsi_berita = $3,
    pinned = $4,
    diterbitkan_pada = $5,
    ditarik_pada = $6,
    updated_by = $7,
    updated_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
RETURNING
    id,
    judul_berita,
    deskripsi_berita,
    pinned,
    diterbitkan_pada,
    ditarik_pada,
    updated_by,
    updated_at,
    deleted_at,
    CASE
        WHEN NOW() < diterbitkan_pada THEN 'WAITING'
        WHEN NOW() >= diterbitkan_pada AND NOW() < ditarik_pada THEN 'ACTIVE'
        WHEN NOW() >= ditarik_pada THEN 'OVER'
        ELSE 'UNKNOWN'
    END AS status
`

type UpdatePemberitahuanParams struct {
	ID              int64              `db:"id"`
	JudulBerita     string             `db:"judul_berita"`
	DeskripsiBerita string             `db:"deskripsi_berita"`
	Pinned          bool               `db:"pinned"`
	DiterbitkanPada pgtype.Timestamptz `db:"diterbitkan_pada"`
	DitarikPada     pgtype.Timestamptz `db:"ditarik_pada"`
	UpdatedBy       string             `db:"updated_by"`
}

type UpdatePemberitahuanRow struct {
	ID              int64              `db:"id"`
	JudulBerita     string             `db:"judul_berita"`
	DeskripsiBerita string             `db:"deskripsi_berita"`
	Pinned          bool               `db:"pinned"`
	DiterbitkanPada pgtype.Timestamptz `db:"diterbitkan_pada"`
	DitarikPada     pgtype.Timestamptz `db:"ditarik_pada"`
	UpdatedBy       string             `db:"updated_by"`
	UpdatedAt       pgtype.Date        `db:"updated_at"`
	DeletedAt       pgtype.Timestamptz `db:"deleted_at"`
	Status          string             `db:"status"`
}

func (q *Queries) UpdatePemberitahuan(ctx context.Context, arg UpdatePemberitahuanParams) (UpdatePemberitahuanRow, error) {
	row := q.db.QueryRow(ctx, updatePemberitahuan,
		arg.ID,
		arg.JudulBerita,
		arg.DeskripsiBerita,
		arg.Pinned,
		arg.DiterbitkanPada,
		arg.DitarikPada,
		arg.UpdatedBy,
	)
	var i UpdatePemberitahuanRow
	err := row.Scan(
		&i.ID,
		&i.JudulBerita,
		&i.DeskripsiBerita,
		&i.Pinned,
		&i.DiterbitkanPada,
		&i.DitarikPada,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Status,
	)
	return i, err
}
