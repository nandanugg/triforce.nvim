// Code generated by sqlc. DO NOT EDIT.
// source: pemberitahuan.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPemberitahuan = `-- name: CountPemberitahuan :one
SELECT COUNT(1) AS total
FROM pemberitahuan
WHERE
    deleted_at IS NULL
    AND (
        $1 = 'ALL'
        OR ($1 = 'WAITING' AND NOW() < diterbitkan_pada)
        OR ($1 = 'ACTIVE' AND aktif_range @> now())
        OR ($1 = 'OVER' AND NOW() >= ditarik_pada)
    )
    AND (
        $2 = '' OR judul_berita ILIKE CONCAT('%', $2, '%')
    )
`

type CountPemberitahuanParams struct {
	Status      interface{} `db:"status"`
	JudulBerita interface{} `db:"judul_berita"`
}

func (q *Queries) CountPemberitahuan(ctx context.Context, arg CountPemberitahuanParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPemberitahuan, arg.Status, arg.JudulBerita)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const createPemberitahuan = `-- name: CreatePemberitahuan :one
INSERT INTO pemberitahuan (
    judul_berita,
    deskripsi_berita,
    pinned_at,
    diterbitkan_pada,
    ditarik_pada,
    updated_by,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, now()
)
RETURNING
    id,
    judul_berita,
    deskripsi_berita,
    pinned_at,
    diterbitkan_pada,
    ditarik_pada,
    updated_by,
    updated_at,
    CASE
        WHEN NOW() < diterbitkan_pada THEN 'WAITING'
        WHEN NOW() >= diterbitkan_pada AND NOW() < ditarik_pada THEN 'ACTIVE'
        WHEN NOW() >= ditarik_pada THEN 'OVER'
        ELSE 'UNKNOWN'
    END AS status
`

type CreatePemberitahuanParams struct {
	JudulBerita     string             `db:"judul_berita"`
	DeskripsiBerita string             `db:"deskripsi_berita"`
	PinnedAt        pgtype.Timestamptz `db:"pinned_at"`
	DiterbitkanPada pgtype.Timestamptz `db:"diterbitkan_pada"`
	DitarikPada     pgtype.Timestamptz `db:"ditarik_pada"`
	UpdatedBy       string             `db:"updated_by"`
}

type CreatePemberitahuanRow struct {
	ID              int64              `db:"id"`
	JudulBerita     string             `db:"judul_berita"`
	DeskripsiBerita string             `db:"deskripsi_berita"`
	PinnedAt        pgtype.Timestamptz `db:"pinned_at"`
	DiterbitkanPada pgtype.Timestamptz `db:"diterbitkan_pada"`
	DitarikPada     pgtype.Timestamptz `db:"ditarik_pada"`
	UpdatedBy       string             `db:"updated_by"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at"`
	Status          string             `db:"status"`
}

func (q *Queries) CreatePemberitahuan(ctx context.Context, arg CreatePemberitahuanParams) (CreatePemberitahuanRow, error) {
	row := q.db.QueryRow(ctx, createPemberitahuan,
		arg.JudulBerita,
		arg.DeskripsiBerita,
		arg.PinnedAt,
		arg.DiterbitkanPada,
		arg.DitarikPada,
		arg.UpdatedBy,
	)
	var i CreatePemberitahuanRow
	err := row.Scan(
		&i.ID,
		&i.JudulBerita,
		&i.DeskripsiBerita,
		&i.PinnedAt,
		&i.DiterbitkanPada,
		&i.DitarikPada,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const deletePemberitahuan = `-- name: DeletePemberitahuan :execrows
UPDATE pemberitahuan
SET deleted_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
`

func (q *Queries) DeletePemberitahuan(ctx context.Context, id int64) (int64, error) {
	result, err := q.db.Exec(ctx, deletePemberitahuan, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const listActivePemberitahuan = `-- name: ListActivePemberitahuan :many
WITH active_pemberitahuan AS (
    SELECT
        id,
        judul_berita,
        deskripsi_berita,
        pinned_at,
        diterbitkan_pada,
        ditarik_pada,
        updated_by,
        updated_at,
        ROW_NUMBER() OVER (
            ORDER BY pinned_at DESC NULLS LAST
        ) AS pinned_rank
    FROM pemberitahuan
    WHERE
        deleted_at IS NULL
        AND aktif_range @> now()
)
SELECT
    id,
    judul_berita,
    deskripsi_berita,
    pinned_at,
    diterbitkan_pada,
    ditarik_pada,
    updated_by,
    updated_at,
    (pinned_at IS NOT NULL AND pinned_rank = 1) AS is_current_period_pinned
FROM active_pemberitahuan
ORDER BY
    is_current_period_pinned DESC,
    diterbitkan_pada DESC
LIMIT $1 OFFSET $2
`

type ListActivePemberitahuanParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

type ListActivePemberitahuanRow struct {
	ID                    int64              `db:"id"`
	JudulBerita           string             `db:"judul_berita"`
	DeskripsiBerita       string             `db:"deskripsi_berita"`
	PinnedAt              pgtype.Timestamptz `db:"pinned_at"`
	DiterbitkanPada       pgtype.Timestamptz `db:"diterbitkan_pada"`
	DitarikPada           pgtype.Timestamptz `db:"ditarik_pada"`
	UpdatedBy             string             `db:"updated_by"`
	UpdatedAt             pgtype.Timestamptz `db:"updated_at"`
	IsCurrentPeriodPinned pgtype.Bool        `db:"is_current_period_pinned"`
}

func (q *Queries) ListActivePemberitahuan(ctx context.Context, arg ListActivePemberitahuanParams) ([]ListActivePemberitahuanRow, error) {
	rows, err := q.db.Query(ctx, listActivePemberitahuan, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActivePemberitahuanRow
	for rows.Next() {
		var i ListActivePemberitahuanRow
		if err := rows.Scan(
			&i.ID,
			&i.JudulBerita,
			&i.DeskripsiBerita,
			&i.PinnedAt,
			&i.DiterbitkanPada,
			&i.DitarikPada,
			&i.UpdatedBy,
			&i.UpdatedAt,
			&i.IsCurrentPeriodPinned,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPemberitahuan = `-- name: ListPemberitahuan :many
SELECT
    id,
    judul_berita,
    deskripsi_berita,
    pinned_at,
    diterbitkan_pada,
    ditarik_pada,
    updated_by,
    updated_at,
    aktif_range
FROM pemberitahuan
WHERE
    deleted_at IS NULL
    AND (
        $3 = '' OR judul_berita ILIKE CONCAT('%', $3, '%')
    )
ORDER BY
    CASE
        WHEN $4 = 'pinned_asc' THEN pinned_at
    END ASC NULLS LAST,
    CASE
        WHEN $4 = 'pinned_desc' THEN pinned_at
    END DESC NULLS LAST,
    diterbitkan_pada DESC
LIMIT $1 OFFSET $2
`

type ListPemberitahuanParams struct {
	Limit       int32       `db:"limit"`
	Offset      int32       `db:"offset"`
	JudulBerita interface{} `db:"judul_berita"`
	SortBy      interface{} `db:"sort_by"`
}

type ListPemberitahuanRow struct {
	ID              int64                            `db:"id"`
	JudulBerita     string                           `db:"judul_berita"`
	DeskripsiBerita string                           `db:"deskripsi_berita"`
	PinnedAt        pgtype.Timestamptz               `db:"pinned_at"`
	DiterbitkanPada pgtype.Timestamptz               `db:"diterbitkan_pada"`
	DitarikPada     pgtype.Timestamptz               `db:"ditarik_pada"`
	UpdatedBy       string                           `db:"updated_by"`
	UpdatedAt       pgtype.Timestamptz               `db:"updated_at"`
	AktifRange      pgtype.Range[pgtype.Timestamptz] `db:"aktif_range"`
}

func (q *Queries) ListPemberitahuan(ctx context.Context, arg ListPemberitahuanParams) ([]ListPemberitahuanRow, error) {
	rows, err := q.db.Query(ctx, listPemberitahuan,
		arg.Limit,
		arg.Offset,
		arg.JudulBerita,
		arg.SortBy,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPemberitahuanRow
	for rows.Next() {
		var i ListPemberitahuanRow
		if err := rows.Scan(
			&i.ID,
			&i.JudulBerita,
			&i.DeskripsiBerita,
			&i.PinnedAt,
			&i.DiterbitkanPada,
			&i.DitarikPada,
			&i.UpdatedBy,
			&i.UpdatedAt,
			&i.AktifRange,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePemberitahuan = `-- name: UpdatePemberitahuan :one
UPDATE pemberitahuan
SET
    judul_berita = $2,
    deskripsi_berita = $3,
    pinned_at = $4,
    diterbitkan_pada = $5,
    ditarik_pada = $6,
    updated_by = $7,
    updated_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
RETURNING
    id,
    judul_berita,
    deskripsi_berita,
    pinned_at,
    diterbitkan_pada,
    ditarik_pada,
    updated_by,
    updated_at,
    deleted_at,
    CASE
        WHEN NOW() < diterbitkan_pada THEN 'WAITING'
        WHEN NOW() >= diterbitkan_pada AND NOW() < ditarik_pada THEN 'ACTIVE'
        WHEN NOW() >= ditarik_pada THEN 'OVER'
        ELSE 'UNKNOWN'
    END AS status
`

type UpdatePemberitahuanParams struct {
	ID              int64              `db:"id"`
	JudulBerita     string             `db:"judul_berita"`
	DeskripsiBerita string             `db:"deskripsi_berita"`
	PinnedAt        pgtype.Timestamptz `db:"pinned_at"`
	DiterbitkanPada pgtype.Timestamptz `db:"diterbitkan_pada"`
	DitarikPada     pgtype.Timestamptz `db:"ditarik_pada"`
	UpdatedBy       string             `db:"updated_by"`
}

type UpdatePemberitahuanRow struct {
	ID              int64              `db:"id"`
	JudulBerita     string             `db:"judul_berita"`
	DeskripsiBerita string             `db:"deskripsi_berita"`
	PinnedAt        pgtype.Timestamptz `db:"pinned_at"`
	DiterbitkanPada pgtype.Timestamptz `db:"diterbitkan_pada"`
	DitarikPada     pgtype.Timestamptz `db:"ditarik_pada"`
	UpdatedBy       string             `db:"updated_by"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at"`
	DeletedAt       pgtype.Timestamptz `db:"deleted_at"`
	Status          string             `db:"status"`
}

func (q *Queries) UpdatePemberitahuan(ctx context.Context, arg UpdatePemberitahuanParams) (UpdatePemberitahuanRow, error) {
	row := q.db.QueryRow(ctx, updatePemberitahuan,
		arg.ID,
		arg.JudulBerita,
		arg.DeskripsiBerita,
		arg.PinnedAt,
		arg.DiterbitkanPada,
		arg.DitarikPada,
		arg.UpdatedBy,
	)
	var i UpdatePemberitahuanRow
	err := row.Scan(
		&i.ID,
		&i.JudulBerita,
		&i.DeskripsiBerita,
		&i.PinnedAt,
		&i.DiterbitkanPada,
		&i.DitarikPada,
		&i.UpdatedBy,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Status,
	)
	return i, err
}
