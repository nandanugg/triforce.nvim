// Code generated by sqlc. DO NOT EDIT.
// source: user.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countUsersGroupByNIP = `-- name: CountUsersGroupByNIP :one
select count(distinct u.nip)
from "user" u
where u.deleted_at is null
  and ($1::varchar is null or u.nip like concat($1::varchar, '%'))
  and (
    $2::int2 is null
    or (
      select r.is_default from role r where r.id = $2::int2 and r.deleted_at is null
    ) is true
    or u.nip in (
      select ur.nip
      from user_role ur
      join role r on r.id = ur.role_id and r.deleted_at is null
      where ur.role_id = $2::int2 and ur.deleted_at is null
    )
  )
`

type CountUsersGroupByNIPParams struct {
	Nip    pgtype.Text `db:"nip"`
	RoleID pgtype.Int2 `db:"role_id"`
}

func (q *Queries) CountUsersGroupByNIP(ctx context.Context, arg CountUsersGroupByNIPParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUsersGroupByNIP, arg.Nip, arg.RoleID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUserRoles = `-- name: CreateUserRoles :exec
insert into user_role (nip, role_id)
select t.nip, t.role_id
from (
  select
    $1::varchar as nip,
    unnest($2::int2[]) as role_id
) as t
join role r on r.id = t.role_id and r.is_default is false and r.deleted_at is null
where not exists (
  select 1 from user_role as ur
  where ur.nip = t.nip
    and ur.role_id = t.role_id
    and ur.deleted_at is null
)
`

type CreateUserRolesParams struct {
	Nip     string  `db:"nip"`
	RoleIds []int16 `db:"role_ids"`
}

func (q *Queries) CreateUserRoles(ctx context.Context, arg CreateUserRolesParams) error {
	_, err := q.db.Exec(ctx, createUserRoles, arg.Nip, arg.RoleIds)
	return err
}

const deleteUserRoles = `-- name: DeleteUserRoles :exec
update user_role
set deleted_at = now()
where nip = $1
  and role_id <> all($2::int2[])
  and deleted_at is null
`

type DeleteUserRolesParams struct {
	Nip            string  `db:"nip"`
	ExcludeRoleIds []int16 `db:"exclude_role_ids"`
}

func (q *Queries) DeleteUserRoles(ctx context.Context, arg DeleteUserRolesParams) error {
	_, err := q.db.Exec(ctx, deleteUserRoles, arg.Nip, arg.ExcludeRoleIds)
	return err
}

const getUserGroupByNIP = `-- name: GetUserGroupByNIP :one
select
  u.nip,
  json_agg(
    json_build_object(
      'id', u.id,
      'source', u.source,
      'nama', u.nama,
      'email', u.email,
      'last_login_at', u.last_login_at
    )
    order by u.last_login_at desc nulls last
  ) as profiles
from "user" u
where u.nip = $1 and u.deleted_at is null
group by u.nip
`

type GetUserGroupByNIPRow struct {
	Nip      string `db:"nip"`
	Profiles []byte `db:"profiles"`
}

func (q *Queries) GetUserGroupByNIP(ctx context.Context, nip string) (GetUserGroupByNIPRow, error) {
	row := q.db.QueryRow(ctx, getUserGroupByNIP, nip)
	var i GetUserGroupByNIPRow
	err := row.Scan(&i.Nip, &i.Profiles)
	return i, err
}

const getUserNIPByIDAndSource = `-- name: GetUserNIPByIDAndSource :one
select nip from "user"
where id = $1 and source = $2 and deleted_at is null
`

type GetUserNIPByIDAndSourceParams struct {
	ID     pgtype.UUID `db:"id"`
	Source string      `db:"source"`
}

func (q *Queries) GetUserNIPByIDAndSource(ctx context.Context, arg GetUserNIPByIDAndSourceParams) (string, error) {
	row := q.db.QueryRow(ctx, getUserNIPByIDAndSource, arg.ID, arg.Source)
	var nip string
	err := row.Scan(&nip)
	return nip, err
}

const isUserExistsByNIP = `-- name: IsUserExistsByNIP :one
select exists (
  select 1 from "user"
  where nip = $1 and deleted_at is null
)
`

func (q *Queries) IsUserExistsByNIP(ctx context.Context, nip string) (bool, error) {
	row := q.db.QueryRow(ctx, isUserExistsByNIP, nip)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listUserRoleByNIP = `-- name: ListUserRoleByNIP :many
select distinct on (r.service)
  r.service,
  r.nama
from user_role ur
join role r on r.id = ur.role_id and r.deleted_at is null
where ur.nip = $1 and ur.deleted_at is null
order by r.service, ur.updated_at desc
`

type ListUserRoleByNIPRow struct {
	Service pgtype.Text `db:"service"`
	Nama    string      `db:"nama"`
}

func (q *Queries) ListUserRoleByNIP(ctx context.Context, nip string) ([]ListUserRoleByNIPRow, error) {
	rows, err := q.db.Query(ctx, listUserRoleByNIP, nip)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserRoleByNIPRow
	for rows.Next() {
		var i ListUserRoleByNIPRow
		if err := rows.Scan(&i.Service, &i.Nama); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersGroupByNIP = `-- name: ListUsersGroupByNIP :many
select
  u.nip,
  json_agg(
    json_build_object(
      'id', u.id,
      'source', u.source,
      'nama', u.nama,
      'email', u.email,
      'last_login_at', u.last_login_at
    )
    order by u.last_login_at desc nulls last
  ) as profiles
from "user" u
where u.deleted_at is null
  and ($3::varchar is null or u.nip like concat($3::varchar, '%'))
  and (
    $4::int2 is null
    or (
      select r.is_default from role r where r.id = $4::int2 and r.deleted_at is null
    ) is true
    or u.nip in (
      select ur.nip
      from user_role ur
      join role r on r.id = ur.role_id and r.deleted_at is null
      where ur.role_id = $4::int2 and ur.deleted_at is null
    )
  )
group by u.nip
limit $1 offset $2
`

type ListUsersGroupByNIPParams struct {
	Limit  int32       `db:"limit"`
	Offset int32       `db:"offset"`
	Nip    pgtype.Text `db:"nip"`
	RoleID pgtype.Int2 `db:"role_id"`
}

type ListUsersGroupByNIPRow struct {
	Nip      string `db:"nip"`
	Profiles []byte `db:"profiles"`
}

func (q *Queries) ListUsersGroupByNIP(ctx context.Context, arg ListUsersGroupByNIPParams) ([]ListUsersGroupByNIPRow, error) {
	rows, err := q.db.Query(ctx, listUsersGroupByNIP,
		arg.Limit,
		arg.Offset,
		arg.Nip,
		arg.RoleID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersGroupByNIPRow
	for rows.Next() {
		var i ListUsersGroupByNIPRow
		if err := rows.Scan(&i.Nip, &i.Profiles); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLastLoginAt = `-- name: UpdateLastLoginAt :exec
update "user"
set last_login_at = now()
where id = $1 and source = $2
`

type UpdateLastLoginAtParams struct {
	ID     pgtype.UUID `db:"id"`
	Source string      `db:"source"`
}

func (q *Queries) UpdateLastLoginAt(ctx context.Context, arg UpdateLastLoginAtParams) error {
	_, err := q.db.Exec(ctx, updateLastLoginAt, arg.ID, arg.Source)
	return err
}
