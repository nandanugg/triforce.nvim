// Code generated by sqlc. DO NOT EDIT.
// source: role.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countRoles = `-- name: CountRoles :one
select count(1)
from role
where deleted_at is null
`

func (q *Queries) CountRoles(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countRoles)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRolesByIDs = `-- name: CountRolesByIDs :one
select count(1) from role
where id = any($1::int2[]) and deleted_at is null
`

func (q *Queries) CountRolesByIDs(ctx context.Context, ids []int16) (int64, error) {
	row := q.db.QueryRow(ctx, countRolesByIDs, ids)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRole = `-- name: CreateRole :one
insert into role (nama, deskripsi, is_default)
values ($1, $2, $3)
returning id
`

type CreateRoleParams struct {
	Nama      string      `db:"nama"`
	Deskripsi pgtype.Text `db:"deskripsi"`
	IsDefault bool        `db:"is_default"`
}

func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) (int16, error) {
	row := q.db.QueryRow(ctx, createRole, arg.Nama, arg.Deskripsi, arg.IsDefault)
	var id int16
	err := row.Scan(&id)
	return id, err
}

const createRoleResourcePermissions = `-- name: CreateRoleResourcePermissions :exec
insert into role_resource_permission (role_id, resource_permission_id)
select t.role_id, t.resource_permission_id
from (
  select
    $1::int2 as role_id,
    unnest($2::int4[]) as resource_permission_id
) as t
where not exists (
  select 1 from role_resource_permission as rrp
  where rrp.role_id = t.role_id
    and rrp.resource_permission_id = t.resource_permission_id
    and rrp.deleted_at is null
)
`

type CreateRoleResourcePermissionsParams struct {
	RoleID                int16   `db:"role_id"`
	ResourcePermissionIds []int32 `db:"resource_permission_ids"`
}

func (q *Queries) CreateRoleResourcePermissions(ctx context.Context, arg CreateRoleResourcePermissionsParams) error {
	_, err := q.db.Exec(ctx, createRoleResourcePermissions, arg.RoleID, arg.ResourcePermissionIds)
	return err
}

const deleteRoleResourcePermissions = `-- name: DeleteRoleResourcePermissions :exec
update role_resource_permission
set deleted_at = now()
where role_id = $1
  and resource_permission_id <> all($2::int4[])
  and deleted_at is null
`

type DeleteRoleResourcePermissionsParams struct {
	RoleID                       int16   `db:"role_id"`
	ExcludeResourcePermissionIds []int32 `db:"exclude_resource_permission_ids"`
}

func (q *Queries) DeleteRoleResourcePermissions(ctx context.Context, arg DeleteRoleResourcePermissionsParams) error {
	_, err := q.db.Exec(ctx, deleteRoleResourcePermissions, arg.RoleID, arg.ExcludeResourcePermissionIds)
	return err
}

const getRole = `-- name: GetRole :one
select
  r.id,
  r.nama,
  r.deskripsi,
  r.is_default,
  r.is_aktif,
  case
    when r.is_default then
      (
        select count(distinct nip) from "user" u
        where u.deleted_at is null
      )
    else
      (
        select count(1) from user_role ur
        where ur.role_id = r.id and ur.deleted_at is null
          and exists (select 1 from "user" u where u.nip = ur.nip and u.deleted_at is null)
      )
  end::int as jumlah_user
from role r
where r.id = $1 and r.deleted_at is null
`

type GetRoleRow struct {
	ID         int16       `db:"id"`
	Nama       string      `db:"nama"`
	Deskripsi  pgtype.Text `db:"deskripsi"`
	IsDefault  bool        `db:"is_default"`
	IsAktif    bool        `db:"is_aktif"`
	JumlahUser int32       `db:"jumlah_user"`
}

func (q *Queries) GetRole(ctx context.Context, id int16) (GetRoleRow, error) {
	row := q.db.QueryRow(ctx, getRole, id)
	var i GetRoleRow
	err := row.Scan(
		&i.ID,
		&i.Nama,
		&i.Deskripsi,
		&i.IsDefault,
		&i.IsAktif,
		&i.JumlahUser,
	)
	return i, err
}

const listRoleResourcePermissionsByRoleID = `-- name: ListRoleResourcePermissionsByRoleID :many
select
  id,
  resource_permission_id
from role_resource_permission
where role_id = $1 and deleted_at is null
`

type ListRoleResourcePermissionsByRoleIDRow struct {
	ID                   int32 `db:"id"`
	ResourcePermissionID int32 `db:"resource_permission_id"`
}

func (q *Queries) ListRoleResourcePermissionsByRoleID(ctx context.Context, roleID int16) ([]ListRoleResourcePermissionsByRoleIDRow, error) {
	rows, err := q.db.Query(ctx, listRoleResourcePermissionsByRoleID, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRoleResourcePermissionsByRoleIDRow
	for rows.Next() {
		var i ListRoleResourcePermissionsByRoleIDRow
		if err := rows.Scan(&i.ID, &i.ResourcePermissionID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoles = `-- name: ListRoles :many
select
  r.id,
  r.nama,
  r.deskripsi,
  r.is_default,
  r.is_aktif,
  case
    when r.is_default then
      (
        select count(distinct nip) from "user" u
        where u.deleted_at is null
      )
    else
      (
        select count(1) from user_role ur
        where ur.role_id = r.id and ur.deleted_at is null
          and exists (select 1 from "user" u where u.nip = ur.nip and u.deleted_at is null)
      )
  end::int as jumlah_user
from role r
where r.deleted_at is null
order by r.nama
limit $1 offset $2
`

type ListRolesParams struct {
	Limit  int32 `db:"limit"`
	Offset int32 `db:"offset"`
}

type ListRolesRow struct {
	ID         int16       `db:"id"`
	Nama       string      `db:"nama"`
	Deskripsi  pgtype.Text `db:"deskripsi"`
	IsDefault  bool        `db:"is_default"`
	IsAktif    bool        `db:"is_aktif"`
	JumlahUser int32       `db:"jumlah_user"`
}

func (q *Queries) ListRoles(ctx context.Context, arg ListRolesParams) ([]ListRolesRow, error) {
	rows, err := q.db.Query(ctx, listRoles, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRolesRow
	for rows.Next() {
		var i ListRolesRow
		if err := rows.Scan(
			&i.ID,
			&i.Nama,
			&i.Deskripsi,
			&i.IsDefault,
			&i.IsAktif,
			&i.JumlahUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRolesByNIPs = `-- name: ListRolesByNIPs :many
select
  ur.nip,
  r.id,
  r.nama,
  r.is_default,
  r.is_aktif
from user_role ur
join role r on r.id = ur.role_id and r.is_default is false and r.deleted_at is null
where ur.nip = any($1::varchar[]) and ur.deleted_at is null
union all
select
  t.nip,
  r.id,
  r.nama,
  r.is_default,
  r.is_aktif
from (
  select unnest($1::varchar[]) as nip
) as t
join role r on r.is_default and r.deleted_at is null
order by nama
`

type ListRolesByNIPsRow struct {
	Nip       string `db:"nip"`
	ID        int16  `db:"id"`
	Nama      string `db:"nama"`
	IsDefault bool   `db:"is_default"`
	IsAktif   bool   `db:"is_aktif"`
}

func (q *Queries) ListRolesByNIPs(ctx context.Context, nips []string) ([]ListRolesByNIPsRow, error) {
	rows, err := q.db.Query(ctx, listRolesByNIPs, nips)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRolesByNIPsRow
	for rows.Next() {
		var i ListRolesByNIPsRow
		if err := rows.Scan(
			&i.Nip,
			&i.ID,
			&i.Nama,
			&i.IsDefault,
			&i.IsAktif,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRole = `-- name: UpdateRole :one
update role
set
  nama = coalesce($2, nama),
  deskripsi = coalesce($3, deskripsi),
  is_default = coalesce($4, is_default),
  is_aktif = coalesce($5, is_aktif),
  updated_at = now()
where id = $1 and deleted_at is null
returning id
`

type UpdateRoleParams struct {
	ID        int16       `db:"id"`
	Nama      pgtype.Text `db:"nama"`
	Deskripsi pgtype.Text `db:"deskripsi"`
	IsDefault pgtype.Bool `db:"is_default"`
	IsAktif   pgtype.Bool `db:"is_aktif"`
}

func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) (int16, error) {
	row := q.db.QueryRow(ctx, updateRole,
		arg.ID,
		arg.Nama,
		arg.Deskripsi,
		arg.IsDefault,
		arg.IsAktif,
	)
	var id int16
	err := row.Scan(&id)
	return id, err
}
